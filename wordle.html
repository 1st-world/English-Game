<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="description" content="Play Wordle Game! Guess the English word in 6 tries.">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wordle Game</title>
    <link rel="icon" href="favicon.png">
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://hangeul.pstatic.net/hangeul_static/css/nanum-square-neo.css">
    <style></style>
</head>
<body>
    <button class="btn btn-back" id="back-btn">Back</button>
    <button class="btn btn-help" id="help-btn">Help</button>

    <div id="game-container">
        <h1>Wordle Game</h1>
        <div id="word-grid" tabindex="0"></div>
        <div id="message"></div>
        <div id="definition"></div>
        <div class="keyboard" id="keyboard">
            <div class="row">
              <button class="key" tabindex="-1" data-key="q">Q</button>
              <button class="key" tabindex="-1" data-key="w">W</button>
              <button class="key" tabindex="-1" data-key="e">E</button>
              <button class="key" tabindex="-1" data-key="r">R</button>
              <button class="key" tabindex="-1" data-key="t">T</button>
              <button class="key" tabindex="-1" data-key="y">Y</button>
              <button class="key" tabindex="-1" data-key="u">U</button>
              <button class="key" tabindex="-1" data-key="i">I</button>
              <button class="key" tabindex="-1" data-key="o">O</button>
              <button class="key" tabindex="-1" data-key="p">P</button>
            </div>
            <div class="row">
              <button class="key" tabindex="-1" data-key="a">A</button>
              <button class="key" tabindex="-1" data-key="s">S</button>
              <button class="key" tabindex="-1" data-key="d">D</button>
              <button class="key" tabindex="-1" data-key="f">F</button>
              <button class="key" tabindex="-1" data-key="g">G</button>
              <button class="key" tabindex="-1" data-key="h">H</button>
              <button class="key" tabindex="-1" data-key="j">J</button>
              <button class="key" tabindex="-1" data-key="k">K</button>
              <button class="key" tabindex="-1" data-key="l">L</button>
            </div>
            <div class="row">
              <button class="key special" tabindex="-1" data-key="Backspace">⌫</button>
              <button class="key" tabindex="-1" data-key="z">Z</button>
              <button class="key" tabindex="-1" data-key="x">X</button>
              <button class="key" tabindex="-1" data-key="c">C</button>
              <button class="key" tabindex="-1" data-key="v">V</button>
              <button class="key" tabindex="-1" data-key="b">B</button>
              <button class="key" tabindex="-1" data-key="n">N</button>
              <button class="key" tabindex="-1" data-key="m">M</button>
              <button class="key special" tabindex="-1" data-key="Enter">Enter</button>
            </div>
        </div>
        <button class="key" id="new-game-btn" onclick="initializeGame()">New Game</button>
    </div>

    <div class="dialog-overlay" id="howtoPlayDialog">
        <div class="dialog-content">
            <h2>How to Play</h2>
            <ul>
                <li>5글자의 영단어를 추측해야 합니다.</li>
                <li>추측한 단어의 정확성을 글자마다 색상으로 표시:
                    <ul>
                        <li><span class="color-box" style="background-color: #6aaa64;"></span>녹색: 정확한 위치의 정확한 글자</li>
                        <li><span class="color-box" style="background-color: #c9b458;"></span>황색: 단어에 포함되지만 위치가 다른 글자</li>
                        <li><span class="color-box" style="background-color: #787c7e;"></span>회색: 단어에 포함되지 않는 글자</li>
                    </ul>
                </li>
                <li>단어 입력은 최대 6번까지 가능합니다.</li>
            </ul>
            <button class="btn btn-close" onclick="hideDialog(this)">닫기</button>
        </div>
    </div>

    <script>
        const backBtn = document.getElementById('back-btn');
        const helpBtn = document.getElementById('help-btn');
        const howtoPlayDialog = document.getElementById('howtoPlayDialog');

        function showDialog(dialog) {
            dialog.style.visibility = 'visible';
            dialog.style.opacity = '1';
        }

        function hideDialog(element) {
            const dialog = element.closest('.dialog-overlay') || element;
            dialog.style.visibility = 'hidden';
            dialog.style.opacity = '0';
            wordGrid.focus();
        }

        backBtn.addEventListener('click', function() {
            window.history.back();
        });

        helpBtn.addEventListener('click', function(event) {
            event.preventDefault();
            showDialog(howtoPlayDialog);
        });

        howtoPlayDialog.addEventListener('click', function(event) {
            if (event.target === howtoPlayDialog) {
                hideDialog(howtoPlayDialog);
            }
        });

        let WORD_LENGTH = 5;
        const MAX_GUESSES = 6;
        let secretWord = '';
        let secretWordDefinition = '';
        let currentGuess = '';
        let guesses = [];
        let isGameEnd = true;
        let validWordsSet = new Set();
        let validWordsArray = [];

        const STATE_CORRECT = 'state-correct';
        const STATE_PRESENT = 'state-present';
        const STATE_ABSENT = 'state-absent';

        const wordGrid = document.getElementById('word-grid');
        const messageElement = document.getElementById('message');
        const definitionElement = document.getElementById('definition');
        const keyboardElement = document.getElementById('keyboard');
        const newGameBtn = document.getElementById('new-game-btn');

        async function loadLocalWords() {
            try {
                const response = await fetch('words_alpha_sorted.txt');
                if (!response.ok) {
                    throw new Error('Local words list load failed.');
                }
                const text = await response.text();
                const words = text.split(/\r?\n/).map(w => w.trim().toUpperCase()).filter(w => w.length === WORD_LENGTH && /^[A-Z]+$/.test(w));
                validWordsArray = words;
                validWordsSet = new Set(words);
                console.log(`Local words list loaded: ${validWordsSet.size} words.`);
                return true;
            } catch (error) {
                console.error('System Error in loadLocalWords(): ', error);
                return false;
            }
        }

        async function getRandomWord() {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);
                const response = await fetch(`https://random-word-api.vercel.app/api?words=1&length=${WORD_LENGTH}`, {
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                if (!response.ok) {
                    throw new Error(`API Server Error: ${response.status}`);
                }
                const data = await response.json();
                return data[0].toUpperCase();
            } catch (error) {
                if (validWordsArray.length > 0) {
                    console.warn('API Failed, using local words list.');
                    const randomIndex = Math.floor(Math.random() * validWordsArray.length);
                    return validWordsArray[randomIndex];
                }
                console.error('System Error in getRandomWord(): ', error);
                return 'ERROR';
            }
        }

        async function getDefinition(word) {
            try {
                const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                const data = await response.json();
                if (response.ok) {
                    if (data[0]?.meanings[0]?.definitions[0]?.definition) {
                        return data[0].meanings[0].definitions[0].definition;
                    } else {
                        throw new Error('Malformed Data Structure');
                    }
                } else {
                    if (data.title === "No Definitions Found") {
                        if (word.endsWith('s')) {
                            // If the word ends with 's', remove it and search again
                            return await getDefinition(word.slice(0, -1));
                        }
                        else {
                            return null;
                        }
                    } else {
                        throw new Error(`API Server Error: ${response.status}`);
                    }
                }
            } catch (error) {
                console.error('System Error in getDefinition(): ', error);
                throw error;
            }
        }

        async function initializeGame() {
            newGameBtn.disabled = true;
            newGameBtn.style.cursor = 'default';
            messageElement.textContent = '';
            definitionElement.textContent = '';

            if (validWordsSet.size === 0) {
                const success = await loadLocalWords();
                if (!success) {
                    alert('Failed to load local words list. Please check your files or contact the administrator.');
                    messageElement.textContent = '오류가 발생했습니다.';
                    return;
                }
            }

            let attempts = 0;
            while (true) {
                attempts++;
                if (attempts === 1) {
                    messageElement.textContent = '로드 중...';
                } else {
                    messageElement.textContent = `로드 중... (재시도: ${attempts}회)`;
                }
                secretWord = await getRandomWord();
                if (!validWordsSet.has(secretWord)) continue;
                try {
                    const def = await getDefinition(secretWord.toLowerCase());
                    if (def) {
                        secretWordDefinition = def;
                        break; 
                    } else {
                        console.log(`Skipped (No definition): ${secretWord}`);
                        continue;
                    }
                } catch (error) {
                    console.warn("Dictionary API down. Starting without definition.");
                    secretWordDefinition = "⚠️ The definition could not be loaded due to connection issues.";
                    break;
                }
            }
            initializeGrid();
            currentGuess = '';
            guesses = [];
            messageElement.textContent = '';
            document.querySelectorAll('.key').forEach(key => {
                key.classList.remove(STATE_CORRECT, STATE_PRESENT, STATE_ABSENT);
            })
            wordGrid.focus();
            newGameBtn.disabled = false;
            newGameBtn.style.cursor = 'pointer';
            isGameEnd = false;
        }

        function initializeGrid() {
            wordGrid.style.setProperty('--word-length', WORD_LENGTH);
            updateLetterBoxSize();

            const isEmpty = (wordGrid.children.length === 0) || (guesses.length === 0 && currentGuess === '');
            if (isEmpty) {
                wordGrid.innerHTML = '';
                for (let i = 0; i < MAX_GUESSES; i++) {
                    for (let j = 0; j < WORD_LENGTH; j++) {
                        const letterBox = document.createElement('div');
                        letterBox.className = 'letter-box intro-pop';
                        letterBox.addEventListener('animationend', () => {
                            letterBox.classList.remove('intro-pop');
                        }, { once: true });
                        wordGrid.appendChild(letterBox);
                    }
                }
            } else {
                const letterBoxes = wordGrid.children;
                for (let i = 0; i < letterBoxes.length; i++) {
                    const letterBox = letterBoxes[i];
                    letterBox.classList.remove('pop', 'intro-pop');
                    void letterBox.offsetWidth;     // Force a reflow by accessing an offset property
                    const delay = i * 20;
                    setTimeout(() => {
                        letterBox.classList.add('reset-flip');
                    }, delay);
                    setTimeout(() => {
                        letterBox.textContent = '';
                        letterBox.removeAttribute('data-status');
                        letterBox.className = 'letter-box reset-flip';
                    }, delay + 250);    // delay + (animation: reset-filp 0.5s / 2)
                    letterBox.addEventListener('animationend', () => {
                        letterBox.classList.remove('reset-flip');
                    }, { once: true });
                }
            }
        }

        function updateLetterBoxSize() {
            const totalPadding = 20;
            const totalGap = (WORD_LENGTH - 1) * parseFloat(getComputedStyle(wordGrid).getPropertyValue('gap').trim());
            const minWidth = 30;
            const maxWidth = 50;
            let boxWidth = Math.floor((wordGrid.parentElement.clientWidth - totalPadding - totalGap) / WORD_LENGTH);
            boxWidth = Math.max(minWidth, Math.min(maxWidth, boxWidth));
            document.documentElement.style.setProperty('--letter-box-size', `${boxWidth}px`);
        }

        function updateGrid() {
            const letterBoxes = wordGrid.children;
            const keyboardState = {};

            for (let i = 0; i < MAX_GUESSES; i++) {
                for (let j = 0; j < WORD_LENGTH; j++) {
                    const letterBox = letterBoxes[i * WORD_LENGTH + j];
                    const oldText = letterBox.textContent;
                    letterBox.classList.remove(STATE_CORRECT, STATE_PRESENT, STATE_ABSENT);

                    if (i < guesses.length) {
                        const letter = guesses[i][j];
                        const stateClass = getStates(guesses[i])[j];
                        updateKeyboardState(keyboardState, letter, stateClass);
                        letterBox.textContent = letter;
                        letterBox.classList.add(stateClass);
                        letterBox.classList.remove('pop');
                        letterBox.removeAttribute('data-status');
                    } else if (i === guesses.length && j < currentGuess.length) {
                        const letter = currentGuess[j];
                        letterBox.textContent = letter;
                        letterBox.setAttribute('data-status', 'filled');
                        if (oldText !== letter) {
                            letterBox.classList.remove('pop');  // Remove the class in case it's still present
                            void letterBox.offsetWidth;         // Force a reflow by accessing an offset property
                            letterBox.classList.add('pop');
                            letterBox.addEventListener('animationend', () => {
                                letterBox.classList.remove('pop');
                            }, { once: true });
                        }
                    } else {
                        letterBox.textContent = '';
                        letterBox.removeAttribute('data-status');
                        letterBox.classList.remove('pop');
                    }
                }
            }
            applyKeyboardState(keyboardState);
        }

        function getStates(guess) {
            const states = Array(WORD_LENGTH).fill(STATE_ABSENT);
            const secretLetterCount = {};

            for (let i = 0; i < WORD_LENGTH; i++) {
                secretLetterCount[secretWord[i]] = (secretLetterCount[secretWord[i]] || 0) + 1;
            }
            for (let i = 0; i < WORD_LENGTH; i++) {
                if (guess[i] === secretWord[i]) {
                    states[i] = STATE_CORRECT;
                    secretLetterCount[guess[i]]--;
                }
            }
            for (let i = 0; i < WORD_LENGTH; i++) {
                if (states[i] !== STATE_CORRECT && secretLetterCount[guess[i]] > 0) {
                    states[i] = STATE_PRESENT;
                    secretLetterCount[guess[i]]--;
                }
            }
            return states;
        }

        function updateKeyboardState(state, letter, stateClass) {
            const priority = {
                [STATE_CORRECT]: 3,
                [STATE_PRESENT]: 2,
                [STATE_ABSENT]: 1
            };
            if (!state[letter] || priority[stateClass] > priority[state[letter]]) {
                state[letter] = stateClass;
            }
        }

        function applyKeyboardState(state) {
            for (const [letter, stateClass] of Object.entries(state)) {
                const key = document.querySelector(`.key[data-key="${letter.toLowerCase()}"]`);
                if (key) {
                    key.classList.remove(STATE_CORRECT, STATE_PRESENT, STATE_ABSENT);
                    key.classList.add(stateClass);
                }
            }
        }

        async function handleGameEnd(isWin) {
            isGameEnd = true;
            if (isWin) {
                messageElement.textContent = '축하합니다! 정답입니다!';
            } else {
                messageElement.textContent = `GAME OVER! 정답은 ${secretWord} 입니다.`;
            }
            definitionElement.innerHTML = `정답의 의미: <a href="https://en.wiktionary.org/wiki/${secretWord.toLowerCase()}" target="_blank" rel="noopener noreferrer" title="자세히 보기">${secretWordDefinition}</a>`;
        }

        function handleKeyDown(event) {
            let key = event.key || (event.keyCode !== undefined ? String.fromCharCode(event.keyCode) : '');
            const gameFocusAllowList = [wordGrid, document.body, null];
            const isGamePlayable = gameFocusAllowList.includes(document.activeElement);

            if (key === 'Escape') return hideDialog(howtoPlayDialog);
            if (!isGamePlayable) return;
            if (guesses.length >= MAX_GUESSES || isGameEnd) return;

            if (key === 'Enter' || key === 'Space' || key === ' ') {
                event.preventDefault();
                messageElement.textContent = '';
                if (currentGuess.length !== WORD_LENGTH) {
                    messageElement.textContent = `단어는 ${WORD_LENGTH}글자여야 합니다.`;
                    shakeRow();
                    return;
                }
                if (validWordsSet.size > 0 && !validWordsSet.has(currentGuess)) {
                    messageElement.textContent = "단어 목록에 없는 단어입니다.";
                    shakeRow();
                    return;
                }
                guesses.push(currentGuess);
                if (currentGuess === secretWord) {
                    handleGameEnd(true);
                } else if (guesses.length === MAX_GUESSES) {
                    handleGameEnd(false);
                }
                currentGuess = '';
            } else if (key === 'Backspace') {
                currentGuess = currentGuess.slice(0, -1);
                messageElement.textContent = '';
            } else if (/^[A-Za-z]$/.test(key) && currentGuess.length < WORD_LENGTH) {
                currentGuess += key.toUpperCase();
                messageElement.textContent = '';
            }
            updateGrid();
        }

        function shakeRow() {
            const start_idx = guesses.length * WORD_LENGTH;
            const end_idx = start_idx + WORD_LENGTH;
            const letterBoxes = wordGrid.children;

            for (let i = start_idx; i < end_idx; i++) {
                const letterBox = letterBoxes[i];
                letterBox.classList.remove('shake');    // Remove the class in case it's still present
                void letterBox.offsetWidth;             // Force a reflow by accessing an offset property
                letterBox.classList.add('shake');
                letterBox.addEventListener('animationend', () => {
                    letterBox.classList.remove('shake');
                }, { once: true });
            }
        }

        document.querySelectorAll('.key').forEach(button => {
            button.addEventListener('mousedown', (event) => {
                event.preventDefault();
            });

            button.addEventListener('click', (event) => {
                const keyboardEvent = new KeyboardEvent('keydown', {key: event.target.getAttribute('data-key')});
                handleKeyDown(keyboardEvent);
            });
        });

        document.addEventListener('keydown', handleKeyDown);

        window.addEventListener('resize', updateLetterBoxSize);

        initializeGame();
    </script>
</body>
</html>
